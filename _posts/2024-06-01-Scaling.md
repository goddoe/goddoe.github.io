---
layout: post
title:  "Scaling"
date:   2024-06-01 23:44:00 +0900
categories: [Research, Engineering]
---

<style>
.lang-switch {
  font-size: 0.85em;
  color: #999;
  margin-bottom: 20px;
}
.lang-switch a {
  color: #999;
  text-decoration: none;
  cursor: pointer;
}
.lang-switch a:hover {
  color: #666;
}
.lang-switch a.active {
  color: #333;
  font-weight: 600;
}
.lang-en, .lang-ko { display: none; }
.lang-en.active, .lang-ko.active { display: block; }
</style>

<div class="lang-switch">
  <a id="btn-en" onclick="setLang('en')">EN</a> | <a id="btn-ko" onclick="setLang('ko')">KO</a>
</div>

<div class="lang-en" markdown="1">

As an AI Research Engineer, I have conducted and designed various ML/DL, LLM experiments and have learned a lot from them.

I want to share my experiences and insights to help others who are solving similar AI-related problems. Rather than writing all my experiences and know-how at once, I plan to share them piece by piece.

The first topic I want to share is Scaling.

**TL;DR**

1. Find a methodology that shows monotonically increasing performance when scaled.
2. Create a model "f(model size or dataset size or …) = score" through scaling experiments that can predict performance as scaling increases.
3. Use the model "f(model size or dataset size or …) = score" to decide whether to push this methodology further or move on to another one.

As an engineer, to solve a problem, you need to find a technology that can solve it well and push it to the extreme to improve performance. Ideally, we find a technique where the performance increases monotonically as we scale it up.

In many cases, performance increases linearly or like a log function. We push performance enhancement methodologies to their limits through scaling until we encounter a plateau and solve the problem by improving performance.

This scaling to solve problems can also be observed in other domains outside of AI/ML. In semiconductors, circuits are scaled by making the circuit linewidth thinner through nanoprocessing every year to increase circuit density. GPUs are scaled by increasing the number of CUDA cores.

In LLMs, the scaling law, where performance continues to improve as the model size is scaled up, is very well-known.

In AI/ML problems, aside from model size, another aspect that can be scaled is the dataset. In AI/ML problems, rather than changing the model architecture or training techniques, scaling the amount of data and improving its quality is more cost-effective for enhancing model performance.

And in many cases, by conducting scaling experiments on the dataset and measuring performance based on the number of data samples, we can create a model that predicts performance based on the number of data samples.

Generally, performance increases on a log scale as the number of data samples increases, so if you plot log(dataset size) vs score, you will see a linear relationship and can find a function "f(dataset size) = score" through linear fitting that predicts performance based on the number of data samples.

By using this function, we can predict how much performance gain we can expect when scaling this methodology and decide whether to continue scaling the current data collection methodology, switch to collecting different data, or move on to another aspect besides data.

And this is actually the most basic concept taught in ML 101. This is fundamental in LLM experiments as well, and not only I, but OpenAI researchers also emphasize and invest in scaling research with many experiments.

Currently, many new AI, LLM technologies are emerging, and it seems like these basic aspects are often overlooked in recent research and experiments. However, LLMs are still ML, so I believe it is important to always remember and experiment with the fundamentals of ML. I believe that keeping the basics first is the faster way to solve problems.

</div>

<div class="lang-ko" markdown="1">

AI 리서치 엔지니어로서 다양한 ML/DL, LLM 실험을 수행하고 설계하면서 많은 것을 배웠습니다.

비슷한 AI 관련 문제를 해결하고 있는 분들에게 도움이 되고자 제 경험과 인사이트를 공유하고 싶습니다. 모든 경험과 노하우를 한 번에 쓰기보다는 조금씩 나눠서 공유할 계획입니다.

첫 번째로 공유하고 싶은 주제는 스케일링입니다.

**TL;DR**

1. 스케일을 키웠을 때 성능이 단조 증가하는 방법론을 찾는다.
2. 스케일링 실험을 통해 스케일이 증가함에 따라 성능을 예측할 수 있는 모델 "f(모델 크기 또는 데이터셋 크기 또는 …) = 점수"를 만든다.
3. 이 모델 "f(모델 크기 또는 데이터셋 크기 또는 …) = 점수"를 사용하여 이 방법론을 더 밀고 나갈지, 다른 것으로 넘어갈지 결정한다.

엔지니어로서 문제를 해결하려면 그 문제를 잘 해결할 수 있는 기술을 찾아 극한까지 밀어붙여 성능을 향상시켜야 합니다. 이상적으로는 스케일을 키울수록 성능이 단조 증가하는 기술을 찾습니다.

많은 경우 성능은 선형적으로 또는 로그 함수처럼 증가합니다. 우리는 고원(plateau)에 도달할 때까지 스케일링을 통해 성능 향상 방법론을 한계까지 밀어붙이고, 성능을 개선하여 문제를 해결합니다.

문제 해결을 위한 이러한 스케일링은 AI/ML 외의 다른 분야에서도 관찰됩니다. 반도체에서는 매년 나노 공정을 통해 회로 선폭을 더 얇게 만들어 회로 밀도를 높이는 방식으로 회로를 스케일링합니다. GPU는 CUDA 코어 수를 늘리는 방식으로 스케일링됩니다.

LLM에서는 모델 크기가 커질수록 성능이 계속 향상되는 스케일링 법칙이 매우 잘 알려져 있습니다.

AI/ML 문제에서 모델 크기 외에 스케일링할 수 있는 또 다른 측면은 데이터셋입니다. AI/ML 문제에서 모델 아키텍처나 학습 기법을 바꾸는 것보다 데이터의 양을 늘리고 품질을 개선하는 것이 모델 성능 향상에 더 비용 효율적입니다.

그리고 많은 경우, 데이터셋에 대한 스케일링 실험을 수행하고 데이터 샘플 수에 따른 성능을 측정함으로써 데이터 샘플 수에 기반한 성능 예측 모델을 만들 수 있습니다.

일반적으로 데이터 샘플 수가 증가함에 따라 성능은 로그 스케일로 증가하므로, log(데이터셋 크기) vs 점수를 그래프로 그리면 선형 관계를 볼 수 있고, 선형 피팅을 통해 데이터 샘플 수에 기반한 성능을 예측하는 함수 "f(데이터셋 크기) = 점수"를 찾을 수 있습니다.

이 함수를 사용하여 이 방법론을 스케일링할 때 얼마나 많은 성능 향상을 기대할 수 있는지 예측하고, 현재 데이터 수집 방법론을 계속 스케일링할지, 다른 데이터를 수집하는 것으로 전환할지, 또는 데이터 외의 다른 측면으로 넘어갈지 결정할 수 있습니다.

그리고 이것은 사실 ML 101에서 가르치는 가장 기본적인 개념입니다. 이것은 LLM 실험에서도 기본이며, 저뿐만 아니라 OpenAI 연구원들도 많은 실험을 통해 스케일링 연구를 강조하고 투자합니다.

현재 많은 새로운 AI, LLM 기술이 등장하고 있고, 최근 연구와 실험에서 이러한 기본적인 측면이 종종 간과되는 것 같습니다. 하지만 LLM도 여전히 ML이므로, ML의 기본을 항상 기억하고 실험하는 것이 중요하다고 생각합니다. 기본을 먼저 지키는 것이 문제를 해결하는 더 빠른 방법이라고 믿습니다.

</div>

<script>
function setLang(lang) {
  document.querySelector('.lang-en').classList.remove('active');
  document.querySelector('.lang-ko').classList.remove('active');
  document.getElementById('btn-en').classList.remove('active');
  document.getElementById('btn-ko').classList.remove('active');

  document.querySelector('.lang-' + lang).classList.add('active');
  document.getElementById('btn-' + lang).classList.add('active');
  localStorage.setItem('lang', lang);
}

(function() {
  var saved = localStorage.getItem('lang');
  if (saved) {
    setLang(saved);
  } else {
    var browserLang = navigator.language || navigator.userLanguage;
    setLang(browserLang.startsWith('ko') ? 'ko' : 'en');
  }
})();
</script>
